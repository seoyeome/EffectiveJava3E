## 9-10. 네이티브 메소드는 신중히 사용하라 [아이템66] 
- 자바 네이티브 인터페이스(JNI)는 -> 자바 프로그램이 '네이티브 메소드를 호출'하는 기술
  - *네이티브 메소드 : C, C++ 같은 네이티브 프로그래밍 언어로 작성한 메소드를 말함 
  - ```
    *네이티브 프로그래밍 언어 ( = 고수준 언어로 작성됨 ) 
        - 특정 컴퓨터 아키텍처에 직접적으로 실행되도록 설계된 프로그래밍 언어 
          이 언어들은 기계어 수준의 명령어와 밀접하게 관련되서
          하드웨어와 직접 상호작용할 수 있음
          ex) C, C++, Assembly Language
          => 주로 컴파일러에 의해 직접 기계어로 변환되서 실행됨
    ```
- 네이티브 메소드 주요 쓰임 3가지
  - 1. 레지스트리 같은 플랫폼 특화 기능 사용
       - 자바로 만든 어플리케이션에서는 특정 파일을 Windows 레지스트리에 등록하려면 직접 접근하기 어렵지만,
         네이티브 메소드를 사용하여 C, C++로 작성된 코드를 호출하여 레지스트리 조작을 수행할 수 있다고 함
       - windows 레지스트리 : 마이크로소프트 Windows 운영 체제에서 시스템 설정/구성 정보를 저장하는 중요한 데이터베이스임
  - 2. 네이티브 코드로 작성된 기존 라이브러리를 사용함
       ex) 레거시 데이터를 사용하는 레거시 라이브러리
       - 자바 어플리케이션에서는 이미지 처리에 특화된 C언어로 작성된 라이브러리를 사용하고 싶을 때 네이티브 메소드를 사용하여
         자바에서 해당 C 언어 라이브러리 함수를 직접 호출하여 이미지 처리 작업을 수행할 수 있음
  - 3. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성
       - 렌더링 파이프라인 중에서 성능에 큰 영향을 미치는 부분은 네이티브 언어로 작성되어 있음
         이 부분을 네이티브 언어로 최적화함으로써 전반적인 어플리케이션의 성능을 향상시킬 수 있음
  
- But, 자바도 성숙해지면서 하부 플랫폼 기능들을 점차 흡수하고 있고, 네이티브 메소드를 사용할 필요가 줄어들고 있음
  - ex) 자바9에서 process API를 추가해 OS 프로세스에 접근하는 길을 열어줌
- 고성능의 다중 정밀 연산이 필요한 자바 프로그래머인 경우 -> 네이티브 메소드를 통해 GMP(다중 정밀 연산 라이브러리)를 사용해도 성능에 안좋지 않음

- 단점
  - 네이티브 언어가 안전하지 않음 > 즉, 이 네이티브 메소드르 사용하는 어플리케이션도 '메모리 훼손 오류'로부터 더 이상 안전하지 않음
  - 네이티브 언어는 자바보다도 플랫폼을 많이 타서 이식성도 낮고 + 디버깅도 어려움 + 주의하지 않으면 속도가 오히려 느려짐
    - GC가 네이티브 메모리는 자동회수x + 추격할 수 없음
  - 네이티브 메소드 - 자바 코드 -> 사이의 '접착 코드(glue code)'를 작성해야하는데 이는 귀찮은 작업임
    -  ```
       // [자바 코드]
       public class NativeExample {
          // 네이티브 메소드를 선언합니다.
          public native void nativeFunction(); // 이때, nativeFunction이 접착코드가 됨

          // 정적 블록에서 라이브러리 로딩을 수행합니다.
          static {
             System.loadLibrary("NativeLibrary");
          }

          public static void main(String[] args) {
             NativeExample example = new NativeExample();
             example.nativeFunction();
          }
       }
       
       // [네이티브 코드]
       #include <stdio.h>
       #include <jni.h>

       // 네이티브 메소드 정의
       JNIEXPORT void JNICALL Java_NativeExample_nativeFunction(JNIEnv *env, jobject obj) {
          printf("Hello from native code!\n");
       }
       ```

***
## 9-11. 최적화는 신중히 하라 [아이템67] 
- 최적화를 섣불리 진행하면 해로운 결과로 이어지기 쉬움
- 좋은 프로그램은 '정보 은닉 원칙'을 따름
- 성능을 제한하는 설계를 피하기
  - 완성 후 변경하기 어려운 설계 요소는 -> 컴포넌트 or 외부 시스템과의 소통 방식
  - ex) API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등
  => 위의 설계 요소들은 완성 후 변경하기 어렵/불가능 + 시스템 성능 심각하게 제한
- API를 설계할 때 성능에 주는 영향을 고려하기
  - public 타입을 가변으로 만들면 -> 불필요한 방어적 복사를 수없이 유발할 수 있음
  - 컴포지션으로 해결할 수 있음에도 '상속 방식'으로 설계한 public 클래스는 상위 클래스에 영원히 종속됨
  - 인터페이스가 있는데 굳이 구현 타입을 사용하는 것은 특정 구현체에 종속되게 함
- 각각의 최적화 시도 전후로 성능 측정하기
- 프로파일링 도구는 최적화 노력을 어디에 집중해야할지 찾는데 도움을 줌
  - *프로파일링 도구 : 소프트웨어 어플리케이션의 실행 중 성능/자원 사용에 관한 정보를 수집/분석하는 도구
    - 시간 복잡성 분석
    - 메모리 사용 분석
    - CPU 사용분석
    - 스레드 및 동기화 분석
    - 등등
- jmh도 프로파일링 같은 도구임
  - 자바 코드의 상세한 성능을 알기 쉽게 보여주는 마이크로 벤치마킹 프레임워크
- [결론] 어떤 알고리즘을 사용했는지 살펴보는 것이 가장 먼저 할일 

***
## 9-12. 일반적으로 통용되는 명명규칙을 따르라 [아이템68] 
- 자바 언어 명세
  - 자바의 명명규칙이 잘 정립되어 있음 
- 크게 2가지 범주로 나뉨
  - 1. 철자
    - 패키지, 클래스, 인터페이스, 메소드, 필드, 타입 변수의 이름을 다룸
    - 위의 규칙들은 특별한 이유가 없는 한 반드시 따라야 함 
    - ```
      - 패키지 모듈 이름은 각 요소를 점(.)으로 구분하여 계층적으로 지음
      - 조직의 인터넷 도메인 이름을 역순으로 사용함 ex) com.google
      - 클래스, 인터페이스의 이름은 1개 이상의 단어로 이루어짐, 각 단어는 대문자로 시작
        min, max 처럼 널리 알려진 줄임말 빼고는 줄여쓰지 말기 
      - 메소드, 필드 이름은 첫글자 소문자로 쓴다는 점 빼고는 클래스 명명규칙과 동일하나
        상수 필드는 예외
      - 타입 매개변수 이름은 보통 1문자로 표현
        임의의 타입에 T, 컬렉션 원소의 타입은 E, 맵의 키/값에는 K, V를, 예외에는 X를, 메소드의 반환 타입은 R 사용
        그 외 타입의 시퀀스에는 T,U,V or T1, T2, T3 사용하기
      ```
  - 2. 문법
    - 철자 규칙과 비교하면 더 유연/논란도 많음 >  패키지에 대한 규칙은 따로 없음 
    - 객체를 생성할 수 있는 클래스의 이름은 보통 '단수 명사, 명사구' 사용 ex) Thread, PriorityQueue 등
    - 객체를 생성할 수 없는 클래스의 이름은 보통 '복수형 명사'로 지음 ex) Collections, Collectors 등
    - 인터페이스 이름은 클래스와 똑같이 짓거나 ex) Collection, Comparator 등 
      able, ible로 끝나는 형용사로 지음 ex) Runnable, Iterable 등
    - 애노테이션은 다양하게 활용되서 지배적인 규칙이 없음 -> 동사/명사/형용사/전치사 등 다양하게 쓰임
    - 어떤 동작을 수행하는 메소드 이름은 '동사, 동사구'
    - 다른 타입의 또 다른 객체를 반환하는 인스턴스 메소드는 보통 toType형태 ex) toString, toArray 등
  

***
## 10-1. 예외는 진짜 예외 상황에서만 사용하라 [아이템69] 
- 예외의 3가지 규칙
  - 1. 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약함
  - 2. try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한됨
  - 3. 배열을 순회하는 표준 관용구는 앞서 걱정한 중복 검사를 수행하지 않음 JVM이 알아서 최적화해 없애줌

- ```
    try {
      int i = 0;
      while(true)
        range[i++].climb();
    } catch(ArrayIndexOutOfBoundsException e) {
    }
  ```
  - 제대로 작동안할 수도 있고
    예외를 사용한 쪽이 훨씬 느림
    반복문 안에 버그가 숨어있다면 이 예외가 버그를 숨겨 디버깅을 어렵게 함
  - 즉, 예외는 예외 상황에서만 사용하기 

- 몇가지 지침
  - 1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 '옵셔널, 특정값' 사용하기
  - 2. 성능이 중요한 상황에서 상태 검사 메소드가 상태 의존적 메소드의 작업일부를 중복 수행한다면 옵셔널이나 특정 값을 선택함
  - 3. 다른 모든 경우엔 상태 검사 메소드 방식이 조금 더 낫다고 할 수 있음, 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기 쉬움

- [결론] 예외는 예외 상황에서 쓸 의도로 설계됬고, 정상적인 제어 흐름에서 사용해서는 안됨
        이를 프로그래머에게 강요하는 API를 만들어서도 안됨 